<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Dashboard Tests</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/10.2.0/mocha.min.css" />
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }

        #fixtures {
            display: none;
        }

        .status-msg {
            padding: 10px;
            background: #e0f2fe;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .error-msg {
            color: red;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <h1>Dashboard Tests</h1>
    <div id="status" class="status-msg">Loading tests...</div>
    <div id="mocha"></div>

    <!-- Test Fixtures (DOM Elements needed by dashboard.js) -->
    <div id="fixtures">
        <div id="app"></div>
        <div id="auth-view">
            <input id="pat-input" value="test-token">
            <button id="login-btn"></button>
        </div>
        <div id="dashboard-view">
            <div id="status-indicator"></div>
            <button id="save-btn"></button>
            <button id="logout-btn"></button>
            <div id="config-editor"></div>
            <div class="action-item">
                <button id="test-action-btn">Run</button>
            </div>
        </div>
        <div id="toast-container"></div>
    </div>

    <!-- Error Handler -->
    <script>
        window.onerror = function (msg, url, line, col, error) {
            document.getElementById('status').innerHTML = `<span style="color:red">Error: ${msg}</span>`;
            console.error(error);
            return false;
        };
    </script>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/4.3.7/chai.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/10.2.0/mocha.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sinon.js/15.0.1/sinon.min.js"></script>

    <!-- Library Check -->
    <script>
        if (typeof chai === 'undefined' || typeof mocha === 'undefined') {
            document.getElementById('status').innerHTML = '<span style="color:red; font-weight:bold">Error: Failed to load external libraries (Chai/Mocha). Check your internet connection.</span>';
            throw new Error('Libraries not loaded');
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sinon.js/15.0.1/sinon.min.js"></script>

    <!-- Setup Mocha -->
    <script class="mocha-init">
        mocha.setup('bdd');
    </script>

    <!-- INLINED Application Code (dashboard.js) -->
    <script>
        // --- Inlined dashboard.js content ---
        const REPO_OWNER = 'amullick-git';
        const REPO_NAME = 'news_bot';
        const CONFIG_PATH = 'config.yaml';
        const API_BASE = 'https://api.github.com';

        const state = {
            config: null,
            sha: null,
            pat: localStorage.getItem('gh_pat') || null
        };

        // UI Element Refs
        // Note: These run immediately, so fixtures MUST be present above
        const els = {
            app: document.getElementById('app'),
            authView: document.getElementById('auth-view'),
            dashView: document.getElementById('dashboard-view'),
            patInput: document.getElementById('pat-input'),
            loginBtn: document.getElementById('login-btn'),
            editor: document.getElementById('config-editor'),
            saveBtn: document.getElementById('save-btn'),
            logoutBtn: document.getElementById('logout-btn'),
            status: document.getElementById('status-indicator'),
            toastContainer: document.getElementById('toast-container')
        };

        // --- Workflow Actions ---
        async function triggerWorkflow(workflowId, btn) {
            if (!state.pat) return showToast('Please login first', 'error');

            const originalText = btn.innerText;
            btn.innerText = 'Starting...';
            btn.disabled = true;

            try {
                const timestamp = new Date().toISOString();

                // 1. Trigger Dispatch
                const response = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/${workflowId}/dispatches`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `token ${state.pat}`,
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({ ref: 'main' })
                });

                if (!response.ok) throw new Error('Failed to trigger workflow');

                showToast('Workflow triggered! Watching for run...', 'success');
                btn.innerText = 'Thinking...'; // Status: Queued/Provisioning

                // 2. Poll for Status
                pollWorkflowStatus(workflowId, timestamp, btn, originalText);

            } catch (error) {
                console.error(error);
                showToast(error.message, 'error');
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        async function pollWorkflowStatus(workflowId, startTime, btn, originalText) {
            let attempts = 0;
            const maxAttempts = 20; // 40 seconds (2s interval)

            const interval = setInterval(async () => {
                attempts++;
                try {
                    // Find runs created AFTER our trigger time
                    const res = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?workflow_id=${workflowId}&created=>${startTime}`, {
                        headers: { 'Authorization': `token ${state.pat}` }
                    });

                    const data = await res.json();

                    if (data.total_count > 0) {
                        const run = data.workflow_runs[0]; // Newest run

                        // Update UI based on status
                        updateActionStatus(btn, run);

                        // If terminal state, stop polling
                        if (run.status === 'completed') {
                            clearInterval(interval);
                            btn.innerText = originalText;
                            btn.disabled = false;
                        }
                    } else if (attempts >= maxAttempts) {
                        // Timeout looking for run
                        clearInterval(interval);
                        btn.innerText = originalText;
                        btn.disabled = false;
                        showToast('Workflow started, but could not find run info.', 'info');
                    }

                } catch (e) {
                    console.error("Polling error", e);
                }
            }, 2000);
        }

        function updateActionStatus(btn, run) {
            // Replace button text or add badge
            const statusMap = {
                'queued': { icon: '‚è≥', label: 'Queued', class: 'queued' },
                'in_progress': { icon: 'üü°', label: 'Running', class: 'in_progress' },
                'completed': { icon: 'üü¢', label: 'Done', class: 'completed' },
                'failure': { icon: 'üî¥', label: 'Failed', class: 'failure' }
            };

            // Check if we effectively finished (completed or failure)
            let state = run.status;
            if (state === 'completed' && run.conclusion === 'failure') state = 'failure';

            const ui = statusMap[state] || { icon: '‚ùì', label: state, class: '' };

            // Update button text to reflect current state
            if (state !== 'completed' && state !== 'failure') {
                btn.innerText = `${ui.icon} ${ui.label}`;
            }

            // Add/Update URL link
            let link = btn.nextElementSibling;
            if (!link || !link.classList.contains('run-link')) {
                link = document.createElement('a');
                link.className = 'run-link';
                link.target = '_blank';
                link.style.marginLeft = '10px';
                link.style.fontSize = '0.8rem';
                link.style.color = '#3b82f6';
                btn.after(link);
            }
            link.href = run.html_url;
            link.innerText = 'View Logs';

            // Cleanup link if done
            if (state === 'failure' || (state === 'completed' && run.conclusion === 'success')) {
                showToast(`Workflow ${run.conclusion || 'finished'}!`, state === 'failure' ? 'error' : 'success');
            }
        }

        function showToast(msg, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = msg;
            els.toastContainer.appendChild(toast);
        }

        // --- End Inlined Logic ---
    </script>

    <!-- Tests -->
    <script>
        const expect = chai.expect;

        describe('Dashboard Logic', () => {
            let fetchStub;
            let btn;

            beforeEach(() => {
                // Mock Fetch
                fetchStub = sinon.stub(window, 'fetch');

                // Reset State
                state.pat = 'test-token';
                localStorage.setItem('gh_pat', 'test-token');

                // Get Fixture Elements
                btn = document.getElementById('test-action-btn');
                btn.innerText = 'Run';
                btn.disabled = false;

                // Clear any links added by previous tests
                const link = btn.nextElementSibling;
                if (link && link.tagName === 'A') link.remove();
            });

            afterEach(() => {
                fetchStub.restore();
            });

            describe('triggerWorkflow', () => {
                it('should send POST request to GitHub API', async () => {
                    // Mock Success Response
                    fetchStub.resolves({
                        ok: true,
                        json: async () => ({})
                    });

                    // Trigger
                    await triggerWorkflow('test.yml', btn);

                    // Assertions
                    expect(fetchStub.calledWithMatch(
                        'https://api.github.com/repos/amullick-git/news_bot/actions/workflows/test.yml/dispatches',
                        {
                            method: 'POST',
                            headers: {
                                'Authorization': 'token test-token',
                                'Accept': 'application/vnd.github.v3+json'
                            },
                            body: JSON.stringify({ ref: 'main' })
                        }
                    )).to.be.true;
                });

                it('should update UI state during request', async () => {
                    fetchStub.resolves({ ok: true, json: async () => ({}) });

                    await triggerWorkflow('test.yml', btn);

                    expect(btn.innerText).to.equal('Thinking...');
                    expect(btn.disabled).to.be.true;
                });

                it('should handle API errors', async () => {
                    fetchStub.resolves({
                        ok: false,
                        statusText: 'server error'
                    });

                    await triggerWorkflow('test.yml', btn);

                    expect(btn.innerText).to.equal('Run'); // Should revert
                    expect(btn.disabled).to.be.false;
                });
            });

            describe('pollWorkflowStatus', () => {
                it('should stop polling when run is found', async () => {
                    const clock = sinon.useFakeTimers();

                    // 1. Dispatch Request (Success)
                    fetchStub.onCall(0).resolves({ ok: true, json: async () => ({}) });

                    // 2. Poll Request (Success with data)
                    fetchStub.onCall(1).resolves({
                        ok: true,
                        json: async () => ({
                            total_count: 1,
                            workflow_runs: [{
                                status: 'completed',
                                conclusion: 'success',
                                html_url: 'http://log-url'
                            }]
                        })
                    });

                    // Start Process
                    await triggerWorkflow('test.yml', btn);

                    // Fast-forward time for poll
                    await clock.tickAsync(2100);

                    // Assertions
                    expect(btn.nextElementSibling.tagName).to.equal('A');
                    expect(btn.nextElementSibling.href).to.equal('http://log-url/');
                    expect(btn.innerText).to.equal('Run'); // Reset after complete

                    clock.restore();
                });
            });
        });

        // Run
        document.getElementById('status').innerText = 'Running tests...';
        mocha.run(() => {
            document.getElementById('status').innerText = 'Tests Completed.';
            document.getElementById('status').style.background = '#dcfce7';
        });
    </script>
</body>

</html>